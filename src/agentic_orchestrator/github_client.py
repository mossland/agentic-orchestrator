"""
GitHub API client for Issues and Labels management.

Handles all GitHub API interactions for the backlog-based workflow.
"""

import os
import time
from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional, List, Dict, Any

import httpx

from .utils.logging import get_logger
from .utils.config import get_env

logger = get_logger(__name__)


# Label constants
class Labels:
    """Standard labels for the orchestrator workflow."""

    # Type labels
    TYPE_IDEA = "type:idea"
    TYPE_PLAN = "type:plan"

    # Status labels
    STATUS_BACKLOG = "status:backlog"
    STATUS_PLANNED = "status:planned"
    STATUS_IN_DEV = "status:in-dev"
    STATUS_DONE = "status:done"

    # Promotion labels (human action)
    PROMOTE_TO_PLAN = "promote:to-plan"
    PROMOTE_TO_DEV = "promote:to-dev"

    # Rejection labels (human action)
    REJECT_PLAN = "reject:plan"

    # Processing markers
    GENERATED_BY_ORCHESTRATOR = "generated:by-orchestrator"
    PROCESSED_TO_PLAN = "processed:to-plan"
    PROCESSED_TO_DEV = "processed:to-dev"

    # Source markers
    SOURCE_TREND = "source:trend"

    # All labels with descriptions for setup
    ALL_LABELS = {
        TYPE_IDEA: {"color": "0052CC", "description": "Idea for a new micro Web3 service"},
        TYPE_PLAN: {"color": "5319E7", "description": "Detailed planning document"},
        STATUS_BACKLOG: {"color": "FBCA04", "description": "In backlog, awaiting review"},
        STATUS_PLANNED: {"color": "0E8A16", "description": "Idea has been planned"},
        STATUS_IN_DEV: {"color": "1D76DB", "description": "Currently in development"},
        STATUS_DONE: {"color": "006B75", "description": "Completed"},
        PROMOTE_TO_PLAN: {"color": "D93F0B", "description": "Human action: Promote idea to planning"},
        PROMOTE_TO_DEV: {"color": "B60205", "description": "Human action: Promote plan to development"},
        REJECT_PLAN: {"color": "E99695", "description": "Human action: Reject plan and re-generate"},
        GENERATED_BY_ORCHESTRATOR: {"color": "C5DEF5", "description": "Auto-generated by orchestrator"},
        PROCESSED_TO_PLAN: {"color": "BFD4F2", "description": "Processed: plan was generated"},
        PROCESSED_TO_DEV: {"color": "BFD4F2", "description": "Processed: dev was started"},
        SOURCE_TREND: {"color": "7057FF", "description": "Idea generated from trend analysis"},
    }


@dataclass
class GitHubIssue:
    """Represents a GitHub Issue."""

    number: int
    title: str
    body: str
    state: str
    labels: List[str]
    created_at: str
    updated_at: str
    html_url: str

    # Optional metadata
    user: Optional[str] = None
    assignees: List[str] = field(default_factory=list)

    @classmethod
    def from_api_response(cls, data: dict) -> "GitHubIssue":
        """Create from GitHub API response."""
        return cls(
            number=data["number"],
            title=data["title"],
            body=data.get("body") or "",
            state=data["state"],
            labels=[label["name"] for label in data.get("labels", [])],
            created_at=data["created_at"],
            updated_at=data["updated_at"],
            html_url=data["html_url"],
            user=data.get("user", {}).get("login"),
            assignees=[a["login"] for a in data.get("assignees", [])],
        )

    def has_label(self, label: str) -> bool:
        """Check if issue has a specific label."""
        return label in self.labels

    def has_any_label(self, labels: List[str]) -> bool:
        """Check if issue has any of the specified labels."""
        return any(label in self.labels for label in labels)


class GitHubAPIError(Exception):
    """Exception for GitHub API errors."""

    def __init__(self, message: str, status_code: int = 0, response: Optional[dict] = None):
        super().__init__(message)
        self.status_code = status_code
        self.response = response


class GitHubRateLimitError(GitHubAPIError):
    """Rate limit exceeded."""

    def __init__(self, message: str, reset_time: Optional[float] = None):
        super().__init__(message, status_code=403)
        self.reset_time = reset_time


class GitHubClient:
    """
    GitHub API client for Issue and Label management.

    Handles:
    - Issue creation and updates
    - Label management
    - Search queries for promotion detection
    """

    API_BASE = "https://api.github.com"

    def __init__(
        self,
        token: Optional[str] = None,
        owner: Optional[str] = None,
        repo: Optional[str] = None,
    ):
        """
        Initialize GitHub client.

        Args:
            token: GitHub personal access token.
            owner: Repository owner.
            repo: Repository name.
        """
        self.token = token or get_env("GITHUB_TOKEN")
        self.owner = owner or get_env("GITHUB_OWNER")
        self.repo = repo or get_env("GITHUB_REPO")

        if not self.token:
            raise GitHubAPIError("GITHUB_TOKEN not set")

        self._client = httpx.Client(
            base_url=self.API_BASE,
            headers={
                "Authorization": f"Bearer {self.token}",
                "Accept": "application/vnd.github+json",
                "X-GitHub-Api-Version": "2022-11-28",
            },
            timeout=30.0,
        )

    @property
    def repo_path(self) -> str:
        """Get the owner/repo path."""
        if not self.owner or not self.repo:
            raise GitHubAPIError("GITHUB_OWNER and GITHUB_REPO must be set")
        return f"{self.owner}/{self.repo}"

    def _request(
        self,
        method: str,
        endpoint: str,
        **kwargs,
    ) -> Any:
        """Make an API request with error handling."""
        try:
            response = self._client.request(method, endpoint, **kwargs)

            # Check for rate limiting
            if response.status_code == 403:
                if "rate limit" in response.text.lower():
                    reset_time = response.headers.get("X-RateLimit-Reset")
                    reset_ts = float(reset_time) if reset_time else None
                    raise GitHubRateLimitError(
                        "GitHub API rate limit exceeded",
                        reset_time=reset_ts,
                    )

            # Check for errors
            if response.status_code >= 400:
                try:
                    error_data = response.json()
                    message = error_data.get("message", response.text)
                except Exception:
                    message = response.text

                raise GitHubAPIError(
                    f"GitHub API error: {message}",
                    status_code=response.status_code,
                    response=error_data if 'error_data' in dir() else None,
                )

            if response.status_code == 204:
                return None

            return response.json()

        except httpx.RequestError as e:
            raise GitHubAPIError(f"Request failed: {e}")

    # Issue operations

    def create_issue(
        self,
        title: str,
        body: str,
        labels: Optional[List[str]] = None,
        assignees: Optional[List[str]] = None,
    ) -> GitHubIssue:
        """
        Create a new issue.

        Args:
            title: Issue title.
            body: Issue body (markdown).
            labels: List of label names.
            assignees: List of assignee usernames.

        Returns:
            Created GitHubIssue.
        """
        data = {
            "title": title,
            "body": body,
        }
        if labels:
            data["labels"] = labels
        if assignees:
            data["assignees"] = assignees

        response = self._request(
            "POST",
            f"/repos/{self.repo_path}/issues",
            json=data,
        )

        issue = GitHubIssue.from_api_response(response)
        logger.info(f"Created issue #{issue.number}: {title}")
        return issue

    def get_issue(self, issue_number: int) -> GitHubIssue:
        """Get an issue by number."""
        response = self._request(
            "GET",
            f"/repos/{self.repo_path}/issues/{issue_number}",
        )
        return GitHubIssue.from_api_response(response)

    def update_issue(
        self,
        issue_number: int,
        title: Optional[str] = None,
        body: Optional[str] = None,
        state: Optional[str] = None,
        labels: Optional[List[str]] = None,
    ) -> GitHubIssue:
        """
        Update an issue.

        Args:
            issue_number: Issue number.
            title: New title (optional).
            body: New body (optional).
            state: New state (open/closed) (optional).
            labels: Replace all labels (optional).

        Returns:
            Updated GitHubIssue.
        """
        data = {}
        if title is not None:
            data["title"] = title
        if body is not None:
            data["body"] = body
        if state is not None:
            data["state"] = state
        if labels is not None:
            data["labels"] = labels

        response = self._request(
            "PATCH",
            f"/repos/{self.repo_path}/issues/{issue_number}",
            json=data,
        )

        issue = GitHubIssue.from_api_response(response)
        logger.info(f"Updated issue #{issue.number}")
        return issue

    def add_labels(self, issue_number: int, labels: List[str]) -> List[str]:
        """Add labels to an issue."""
        response = self._request(
            "POST",
            f"/repos/{self.repo_path}/issues/{issue_number}/labels",
            json={"labels": labels},
        )
        return [label["name"] for label in response]

    def remove_label(self, issue_number: int, label: str) -> None:
        """Remove a label from an issue."""
        try:
            self._request(
                "DELETE",
                f"/repos/{self.repo_path}/issues/{issue_number}/labels/{label}",
            )
            logger.debug(f"Removed label '{label}' from issue #{issue_number}")
        except GitHubAPIError as e:
            if e.status_code != 404:
                raise

    def set_labels(self, issue_number: int, labels: List[str]) -> List[str]:
        """Replace all labels on an issue."""
        response = self._request(
            "PUT",
            f"/repos/{self.repo_path}/issues/{issue_number}/labels",
            json={"labels": labels},
        )
        return [label["name"] for label in response]

    def add_comment(self, issue_number: int, body: str) -> dict:
        """Add a comment to an issue."""
        response = self._request(
            "POST",
            f"/repos/{self.repo_path}/issues/{issue_number}/comments",
            json={"body": body},
        )
        return response

    # Search operations

    def search_issues(
        self,
        labels: Optional[List[str]] = None,
        state: str = "open",
        sort: str = "created",
        order: str = "desc",
        per_page: int = 30,
    ) -> List[GitHubIssue]:
        """
        Search issues by labels.

        Args:
            labels: Labels to filter by.
            state: Issue state (open/closed/all).
            sort: Sort field (created/updated/comments).
            order: Sort order (asc/desc).
            per_page: Results per page.

        Returns:
            List of matching issues.
        """
        # Build search query
        query_parts = [f"repo:{self.repo_path}", f"is:issue"]

        if state != "all":
            query_parts.append(f"state:{state}")

        if labels:
            for label in labels:
                query_parts.append(f'label:"{label}"')

        query = " ".join(query_parts)

        response = self._request(
            "GET",
            "/search/issues",
            params={
                "q": query,
                "sort": sort,
                "order": order,
                "per_page": per_page,
            },
        )

        return [
            GitHubIssue.from_api_response(item)
            for item in response.get("items", [])
        ]

    def find_ideas_to_promote(self) -> List[GitHubIssue]:
        """Find idea issues with promote:to-plan label."""
        return self.search_issues(
            labels=[Labels.TYPE_IDEA, Labels.PROMOTE_TO_PLAN],
            state="open",
        )

    def find_plans_to_promote(self) -> List[GitHubIssue]:
        """Find plan issues with promote:to-dev label."""
        return self.search_issues(
            labels=[Labels.TYPE_PLAN, Labels.PROMOTE_TO_DEV],
            state="open",
        )

    def find_backlog_ideas(self, limit: int = 50) -> List[GitHubIssue]:
        """Find all backlog ideas."""
        return self.search_issues(
            labels=[Labels.TYPE_IDEA, Labels.STATUS_BACKLOG],
            state="open",
            per_page=limit,
        )

    def find_backlog_plans(self, limit: int = 50) -> List[GitHubIssue]:
        """Find all backlog plans."""
        return self.search_issues(
            labels=[Labels.TYPE_PLAN, Labels.STATUS_BACKLOG],
            state="open",
            per_page=limit,
        )

    # Label management

    def ensure_labels_exist(self) -> None:
        """Create all required labels if they don't exist."""
        existing = self._get_existing_labels()

        for label_name, config in Labels.ALL_LABELS.items():
            if label_name not in existing:
                self._create_label(
                    name=label_name,
                    color=config["color"],
                    description=config["description"],
                )
                logger.info(f"Created label: {label_name}")

    def _get_existing_labels(self) -> set:
        """Get set of existing label names."""
        response = self._request(
            "GET",
            f"/repos/{self.repo_path}/labels",
            params={"per_page": 100},
        )
        return {label["name"] for label in response}

    def _create_label(self, name: str, color: str, description: str) -> None:
        """Create a label."""
        self._request(
            "POST",
            f"/repos/{self.repo_path}/labels",
            json={
                "name": name,
                "color": color,
                "description": description,
            },
        )

    # Promotion helpers

    def mark_idea_as_planned(self, issue_number: int) -> GitHubIssue:
        """
        Mark an idea as planned after plan generation.

        Removes promote:to-plan, adds processed:to-plan and status:planned.
        """
        issue = self.get_issue(issue_number)

        new_labels = [
            label for label in issue.labels
            if label not in [Labels.PROMOTE_TO_PLAN, Labels.STATUS_BACKLOG]
        ]
        new_labels.extend([Labels.STATUS_PLANNED, Labels.PROCESSED_TO_PLAN])

        return self.update_issue(issue_number, labels=list(set(new_labels)))

    def mark_plan_as_in_dev(self, issue_number: int) -> GitHubIssue:
        """
        Mark a plan as in-development after dev start.

        Removes promote:to-dev, adds processed:to-dev and status:in-dev.
        """
        issue = self.get_issue(issue_number)

        new_labels = [
            label for label in issue.labels
            if label not in [Labels.PROMOTE_TO_DEV, Labels.STATUS_BACKLOG]
        ]
        new_labels.extend([Labels.STATUS_IN_DEV, Labels.PROCESSED_TO_DEV])

        return self.update_issue(issue_number, labels=list(set(new_labels)))

    def find_rejected_plans(self) -> List[GitHubIssue]:
        """Find plan issues with reject:plan label."""
        return self.search_issues(
            labels=[Labels.TYPE_PLAN, Labels.REJECT_PLAN],
            state="open",
        )

    def reject_plan(self, plan_issue_number: int, idea_issue_number: int) -> tuple:
        """
        Reject a plan and reset the idea for re-planning.

        This:
        1. Closes the rejected PLAN issue
        2. Resets the IDEA issue to allow re-promotion

        Args:
            plan_issue_number: The PLAN issue to reject
            idea_issue_number: The original IDEA issue to reset

        Returns:
            Tuple of (closed_plan_issue, reset_idea_issue)
        """
        # 1. Close the PLAN issue
        plan_labels = [Labels.TYPE_PLAN, "rejected"]
        closed_plan = self.update_issue(
            plan_issue_number,
            state="closed",
            labels=plan_labels,
        )
        logger.info(f"Closed rejected plan #{plan_issue_number}")

        # 2. Reset the IDEA issue
        idea_issue = self.get_issue(idea_issue_number)

        # Remove planning-related labels, keep original type and other labels
        new_labels = [
            label for label in idea_issue.labels
            if label not in [
                Labels.STATUS_PLANNED,
                Labels.PROCESSED_TO_PLAN,
            ]
        ]
        # Add back to backlog with promote label for re-processing
        new_labels.append(Labels.STATUS_BACKLOG)
        new_labels.append(Labels.PROMOTE_TO_PLAN)

        reset_idea = self.update_issue(
            idea_issue_number,
            labels=list(set(new_labels)),
        )
        logger.info(f"Reset idea #{idea_issue_number} for re-planning")

        return closed_plan, reset_idea

    def reset_idea_for_replanning(self, issue_number: int) -> GitHubIssue:
        """
        Reset an idea issue to allow re-planning.

        Removes status:planned and processed:to-plan,
        adds status:backlog and promote:to-plan.
        """
        issue = self.get_issue(issue_number)

        new_labels = [
            label for label in issue.labels
            if label not in [Labels.STATUS_PLANNED, Labels.PROCESSED_TO_PLAN]
        ]
        new_labels.extend([Labels.STATUS_BACKLOG, Labels.PROMOTE_TO_PLAN])

        return self.update_issue(issue_number, labels=list(set(new_labels)))

    def close(self) -> None:
        """Close the HTTP client."""
        self._client.close()

    def __enter__(self):
        return self

    def __exit__(self, *args):
        self.close()
