"""
LLM-based code generation for project scaffolding.

Uses task-based model selection for optimal code generation:
- glm-4.7-flash: Plan parsing (18GB, fast)
- qwen2.5:32b: Code generation (19GB, balanced)
- llama3.3:70b: Architecture design (42GB, complex tasks)
- phi4:14b: Simple tasks/fallback (9.1GB, lightweight)
"""

import logging
import re
from typing import Optional, List, Dict, Any
from dataclasses import dataclass

from .parser import ParsedPlan, TechStack

logger = logging.getLogger(__name__)


@dataclass
class GeneratedFile:
    """A file generated by LLM."""
    path: str
    content: str
    description: str


class ProjectCodeGenerator:
    """
    LLM-based code generator for project scaffolding.

    Uses different models for different tasks:
    - Parsing: glm-4.7-flash (fast, good at structured extraction)
    - Code generation: qwen2.5:32b (balanced quality/speed for code)
    - Architecture: llama3.3:70b (complex reasoning for system design)
    - Simple tasks: phi4:14b (lightweight fallback)
    """

    # Task-based model selection
    TASK_MODELS = {
        "parsing": "glm-4.7-flash",       # Plan parsing, JSON extraction
        "code_generation": "qwen2.5:32b", # Component, API, model generation
        "architecture": "llama3.3:70b",   # Complex system design
        "simple": "phi4:14b",             # Config files, simple docs
        "readme": "qwen2.5:32b",          # README generation
    }

    def __init__(self, router=None):
        """
        Initialize the code generator.

        Args:
            router: HybridLLMRouter for LLM calls
        """
        self.router = router

    async def generate_readme(
        self,
        parsed_plan: ParsedPlan,
        project_name: str,
    ) -> str:
        """
        Generate README.md for the project.

        Args:
            parsed_plan: Parsed plan data
            project_name: Name of the project

        Returns:
            README.md content
        """
        if not self.router:
            return self._generate_readme_template(parsed_plan, project_name)

        prompt = f"""Generate a professional README.md for this project.

Project Name: {project_name}
Summary: {parsed_plan.summary}

Tech Stack:
- Frontend: {parsed_plan.tech_stack.frontend or 'N/A'}
- Backend: {parsed_plan.tech_stack.backend or 'N/A'}
- Database: {parsed_plan.tech_stack.database or 'N/A'}
- Blockchain: {parsed_plan.tech_stack.blockchain or 'N/A'}

Features:
{chr(10).join('- ' + f for f in parsed_plan.features[:10])}

Target Users: {parsed_plan.target_users or 'General developers'}
Duration: {parsed_plan.duration_estimate or 'TBD'}

Generate a complete README.md with:
1. Project title and description
2. Features list
3. Tech stack section with badges
4. Getting Started (installation, setup)
5. Usage examples
6. Project structure
7. Contributing guidelines
8. License placeholder

Output ONLY the markdown content, no explanations."""

        try:
            response = await self.router.route(
                prompt=prompt,
                task_type="documentation",
                model=self.TASK_MODELS["readme"],
                temperature=0.7,
                max_tokens=2000,
            )
            return response.content
        except Exception as e:
            logger.error(f"Failed to generate README: {e}")
            return self._generate_readme_template(parsed_plan, project_name)

    def _generate_readme_template(
        self,
        parsed_plan: ParsedPlan,
        project_name: str,
    ) -> str:
        """Generate a basic README template without LLM."""
        features = "\n".join(f"- {f}" for f in parsed_plan.features[:10])
        tech_parts = []
        if parsed_plan.tech_stack.frontend:
            tech_parts.append(f"- **Frontend**: {parsed_plan.tech_stack.frontend}")
        if parsed_plan.tech_stack.backend:
            tech_parts.append(f"- **Backend**: {parsed_plan.tech_stack.backend}")
        if parsed_plan.tech_stack.database:
            tech_parts.append(f"- **Database**: {parsed_plan.tech_stack.database}")
        if parsed_plan.tech_stack.blockchain:
            tech_parts.append(f"- **Blockchain**: {parsed_plan.tech_stack.blockchain}")
        tech_stack = "\n".join(tech_parts) or "- To be determined"

        return f"""# {project_name}

{parsed_plan.summary or 'A project generated by MOSS.AO'}

## Features

{features or '- To be defined'}

## Tech Stack

{tech_stack}

## Getting Started

### Prerequisites

- Node.js 18+ (if frontend)
- Python 3.10+ (if backend)
- Docker (optional)

### Installation

```bash
# Clone the repository
git clone <repository-url>

# Install dependencies
# For frontend
cd src/frontend && npm install

# For backend
cd src/backend && pip install -r requirements.txt
```

### Running the Project

```bash
# Start frontend
cd src/frontend && npm run dev

# Start backend
cd src/backend && uvicorn app.main:app --reload
```

## Project Structure

```
├── src/
│   ├── frontend/   # Frontend application
│   └── backend/    # Backend API
├── contracts/      # Smart contracts (if applicable)
├── docs/           # Documentation
└── tests/          # Test files
```

## Contributing

Contributions are welcome! Please read our contributing guidelines.

## License

This project is licensed under the MIT License.

---

*Generated by [MOSS.AO](https://ao.moss.land)*
"""

    async def generate_api_routes(
        self,
        parsed_plan: ParsedPlan,
    ) -> List[GeneratedFile]:
        """
        Generate API route stubs based on plan endpoints.

        Args:
            parsed_plan: Parsed plan with API endpoints

        Returns:
            List of generated route files
        """
        if not parsed_plan.api_endpoints or not self.router:
            return []

        files = []

        # Group endpoints by path prefix
        grouped = {}
        for endpoint in parsed_plan.api_endpoints:
            # Extract resource name from path
            parts = endpoint.path.strip('/').split('/')
            resource = parts[0] if parts else "main"
            if resource not in grouped:
                grouped[resource] = []
            grouped[resource].append(endpoint)

        backend = parsed_plan.tech_stack.backend

        for resource, endpoints in grouped.items():
            try:
                if backend == "fastapi":
                    file = await self._generate_fastapi_router(resource, endpoints)
                elif backend == "express":
                    file = await self._generate_express_router(resource, endpoints)
                else:
                    continue

                if file:
                    files.append(file)

            except Exception as e:
                logger.warning(f"Failed to generate routes for {resource}: {e}")

        return files

    async def _generate_fastapi_router(
        self,
        resource: str,
        endpoints: list,
    ) -> Optional[GeneratedFile]:
        """Generate FastAPI router file."""
        endpoints_desc = "\n".join(
            f"- {e.method} {e.path}: {e.description}"
            for e in endpoints
        )

        prompt = f"""Generate a FastAPI router for the "{resource}" resource.

Endpoints needed:
{endpoints_desc}

Requirements:
1. Use FastAPI's APIRouter
2. Include proper type hints with Pydantic models
3. Add docstrings to each endpoint
4. Include error handling
5. Use async functions

Output ONLY the Python code, no markdown or explanations."""

        response = await self.router.route(
            prompt=prompt,
            task_type="code_generation",
            model=self.TASK_MODELS["code_generation"],
            temperature=0.3,
            max_tokens=2000,
        )

        # Clean up response (remove markdown code blocks if present)
        content = response.content
        content = re.sub(r'^```python\n?', '', content)
        content = re.sub(r'\n?```$', '', content)

        return GeneratedFile(
            path=f"src/backend/app/routers/{resource}.py",
            content=content,
            description=f"FastAPI router for {resource}",
        )

    async def _generate_express_router(
        self,
        resource: str,
        endpoints: list,
    ) -> Optional[GeneratedFile]:
        """Generate Express.js router file."""
        endpoints_desc = "\n".join(
            f"- {e.method} {e.path}: {e.description}"
            for e in endpoints
        )

        prompt = f"""Generate an Express.js router for the "{resource}" resource.

Endpoints needed:
{endpoints_desc}

Requirements:
1. Use Express Router
2. Use TypeScript
3. Include proper type definitions
4. Add error handling middleware
5. Use async/await

Output ONLY the TypeScript code, no markdown or explanations."""

        response = await self.router.route(
            prompt=prompt,
            task_type="code_generation",
            model=self.TASK_MODELS["code_generation"],
            temperature=0.3,
            max_tokens=2000,
        )

        content = response.content
        content = re.sub(r'^```(?:typescript|ts)\n?', '', content)
        content = re.sub(r'\n?```$', '', content)

        return GeneratedFile(
            path=f"src/backend/src/routes/{resource}.ts",
            content=content,
            description=f"Express router for {resource}",
        )

    async def generate_data_models(
        self,
        parsed_plan: ParsedPlan,
    ) -> List[GeneratedFile]:
        """
        Generate data model stubs based on plan features.

        Args:
            parsed_plan: Parsed plan data

        Returns:
            List of generated model files
        """
        if not parsed_plan.features or not self.router:
            return []

        backend = parsed_plan.tech_stack.backend
        files = []

        # Extract potential model names from features
        features_text = "\n".join(parsed_plan.features[:10])

        prompt = f"""Analyze these project features and generate appropriate data models.

Features:
{features_text}

Project Summary: {parsed_plan.summary}

Generate {'SQLAlchemy' if backend == 'fastapi' else 'Prisma/TypeORM'} models for the main entities.
Include:
1. Model class definitions with fields
2. Relationships between models
3. Common fields (id, created_at, updated_at)
4. Type annotations

Output ONLY the {'Python' if backend == 'fastapi' else 'TypeScript'} code, no explanations."""

        try:
            response = await self.router.route(
                prompt=prompt,
                task_type="code_generation",
                model=self.TASK_MODELS["code_generation"],
                temperature=0.3,
                max_tokens=2500,
            )

            content = response.content
            # Clean up code blocks
            if backend == "fastapi":
                content = re.sub(r'^```python\n?', '', content)
                path = "src/backend/app/models/models.py"
            else:
                content = re.sub(r'^```(?:typescript|ts)\n?', '', content)
                path = "src/backend/src/models/index.ts"

            content = re.sub(r'\n?```$', '', content)

            files.append(GeneratedFile(
                path=path,
                content=content,
                description="Data models for the project",
            ))

        except Exception as e:
            logger.warning(f"Failed to generate data models: {e}")

        return files

    async def generate_architecture_doc(
        self,
        parsed_plan: ParsedPlan,
        project_name: str,
    ) -> str:
        """
        Generate architecture documentation.

        Uses the larger llama3.3:70b model for complex reasoning.

        Args:
            parsed_plan: Parsed plan data
            project_name: Project name

        Returns:
            Architecture documentation markdown
        """
        if not self.router:
            return self._generate_architecture_template(parsed_plan, project_name)

        prompt = f"""Create a detailed software architecture document for this project.

Project: {project_name}
Summary: {parsed_plan.summary}

Tech Stack:
- Frontend: {parsed_plan.tech_stack.frontend or 'Not specified'}
- Backend: {parsed_plan.tech_stack.backend or 'Not specified'}
- Database: {parsed_plan.tech_stack.database or 'Not specified'}
- Blockchain: {parsed_plan.tech_stack.blockchain or 'Not applicable'}

Features:
{chr(10).join('- ' + f for f in parsed_plan.features[:10])}

API Endpoints:
{chr(10).join(f'- {e.method} {e.path}: {e.description}' for e in parsed_plan.api_endpoints[:10])}

Generate an architecture document with:
1. System Overview (high-level diagram description)
2. Component Architecture
3. Data Flow
4. API Design
5. Database Schema (conceptual)
6. Security Considerations
7. Scalability Notes
8. Deployment Architecture

Output ONLY the markdown content, no explanations."""

        try:
            response = await self.router.route(
                prompt=prompt,
                task_type="architecture",
                model=self.TASK_MODELS["architecture"],
                temperature=0.5,
                max_tokens=3000,
            )
            return response.content
        except Exception as e:
            logger.error(f"Failed to generate architecture doc: {e}")
            return self._generate_architecture_template(parsed_plan, project_name)

    def _generate_architecture_template(
        self,
        parsed_plan: ParsedPlan,
        project_name: str,
    ) -> str:
        """Generate basic architecture template without LLM."""
        return f"""# Architecture: {project_name}

## System Overview

{parsed_plan.summary or 'System architecture overview to be defined.'}

## Tech Stack

| Layer | Technology |
|-------|------------|
| Frontend | {parsed_plan.tech_stack.frontend or 'TBD'} |
| Backend | {parsed_plan.tech_stack.backend or 'TBD'} |
| Database | {parsed_plan.tech_stack.database or 'TBD'} |
| Blockchain | {parsed_plan.tech_stack.blockchain or 'N/A'} |

## Component Architecture

### Frontend
- UI Components
- State Management
- API Client

### Backend
- API Layer
- Business Logic
- Data Access Layer

### Database
- Data Models
- Migrations
- Indexes

## Data Flow

```
User -> Frontend -> API -> Business Logic -> Database
                     ^
                     |
              External Services
```

## API Design

RESTful API following OpenAPI 3.0 specification.

## Security Considerations

- Authentication: JWT/OAuth2
- Authorization: Role-based access control
- Data: Encryption at rest and in transit
- Input validation and sanitization

## Deployment

- Containerized deployment with Docker
- CI/CD pipeline
- Environment management

---

*Generated by MOSS.AO*
"""

    async def generate_component(
        self,
        component_name: str,
        component_type: str,
        framework: str,
        description: str,
    ) -> Optional[GeneratedFile]:
        """
        Generate a single component.

        Args:
            component_name: Name of the component
            component_type: Type (e.g., "page", "component", "hook")
            framework: Framework (e.g., "nextjs", "react", "vue")
            description: What the component should do

        Returns:
            Generated file or None if failed
        """
        if not self.router:
            return None

        if framework in ["nextjs", "react"]:
            return await self._generate_react_component(
                component_name, component_type, description
            )
        elif framework == "vue":
            return await self._generate_vue_component(
                component_name, component_type, description
            )

        return None

    async def _generate_react_component(
        self,
        name: str,
        comp_type: str,
        description: str,
    ) -> Optional[GeneratedFile]:
        """Generate a React/Next.js component."""
        prompt = f"""Generate a React {comp_type} component.

Name: {name}
Description: {description}

Requirements:
1. Use TypeScript
2. Use functional component with hooks
3. Include proper type definitions
4. Use Tailwind CSS for styling
5. Be production-ready

Output ONLY the TSX code, no markdown or explanations."""

        try:
            response = await self.router.route(
                prompt=prompt,
                task_type="code_generation",
                model=self.TASK_MODELS["code_generation"],
                temperature=0.3,
                max_tokens=1500,
            )

            content = response.content
            content = re.sub(r'^```(?:tsx?|typescript)\n?', '', content)
            content = re.sub(r'\n?```$', '', content)

            # Determine path based on type
            if comp_type == "page":
                path = f"src/frontend/src/app/{name.lower()}/page.tsx"
            else:
                path = f"src/frontend/src/components/{name}.tsx"

            return GeneratedFile(
                path=path,
                content=content,
                description=f"React {comp_type}: {name}",
            )

        except Exception as e:
            logger.warning(f"Failed to generate React component {name}: {e}")
            return None

    async def _generate_vue_component(
        self,
        name: str,
        comp_type: str,
        description: str,
    ) -> Optional[GeneratedFile]:
        """Generate a Vue component."""
        prompt = f"""Generate a Vue 3 {comp_type} component.

Name: {name}
Description: {description}

Requirements:
1. Use Composition API with <script setup>
2. Include TypeScript types
3. Use scoped styles
4. Be production-ready

Output ONLY the Vue SFC code, no markdown or explanations."""

        try:
            response = await self.router.route(
                prompt=prompt,
                task_type="code_generation",
                model=self.TASK_MODELS["code_generation"],
                temperature=0.3,
                max_tokens=1500,
            )

            content = response.content
            content = re.sub(r'^```(?:vue|html)\n?', '', content)
            content = re.sub(r'\n?```$', '', content)

            path = f"src/frontend/src/components/{name}.vue"

            return GeneratedFile(
                path=path,
                content=content,
                description=f"Vue {comp_type}: {name}",
            )

        except Exception as e:
            logger.warning(f"Failed to generate Vue component {name}: {e}")
            return None
