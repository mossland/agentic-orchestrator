"""
Git utilities for the Agentic Orchestrator.

Provides helpers for committing, pushing, and managing Git operations.
"""

import os
import re
import subprocess
from dataclasses import dataclass
from pathlib import Path
from typing import Optional, List

from .logging import get_logger

logger = get_logger(__name__)


@dataclass
class CommitInfo:
    """Information about a Git commit."""

    hash: str
    short_hash: str
    message: str
    author: str
    timestamp: str


class GitError(Exception):
    """Exception raised for Git operations."""

    pass


class GitHelper:
    """
    Helper class for Git operations.

    Provides methods for committing changes, pushing to remote,
    and querying repository state.
    """

    def __init__(self, repo_path: Optional[Path] = None):
        """
        Initialize GitHelper.

        Args:
            repo_path: Path to the Git repository. Defaults to current directory.
        """
        self.repo_path = repo_path or Path.cwd()
        self._validate_repo()

    def _validate_repo(self) -> None:
        """Validate that the path is a Git repository."""
        git_dir = self.repo_path / ".git"
        if not git_dir.exists():
            raise GitError(f"Not a Git repository: {self.repo_path}")

    def _run(
        self,
        args: List[str],
        check: bool = True,
        capture: bool = True,
    ) -> subprocess.CompletedProcess:
        """
        Run a Git command.

        Args:
            args: Git command arguments (without 'git').
            check: Raise exception on non-zero exit code.
            capture: Capture stdout and stderr.

        Returns:
            CompletedProcess instance.
        """
        cmd = ["git"] + args
        logger.debug(f"Running: {' '.join(cmd)}")

        try:
            result = subprocess.run(
                cmd,
                cwd=self.repo_path,
                check=check,
                capture_output=capture,
                text=True,
            )
            return result
        except subprocess.CalledProcessError as e:
            raise GitError(f"Git command failed: {' '.join(cmd)}\n{e.stderr}")

    def is_clean(self) -> bool:
        """Check if the working directory is clean."""
        result = self._run(["status", "--porcelain"])
        return len(result.stdout.strip()) == 0

    def has_changes(self) -> bool:
        """Check if there are uncommitted changes."""
        return not self.is_clean()

    def get_current_branch(self) -> str:
        """Get the current branch name."""
        result = self._run(["rev-parse", "--abbrev-ref", "HEAD"])
        return result.stdout.strip()

    def get_status(self) -> str:
        """Get the repository status."""
        result = self._run(["status", "--short"])
        return result.stdout

    def add(self, paths: Optional[List[str]] = None, all: bool = False) -> None:
        """
        Stage files for commit.

        Args:
            paths: Specific paths to add.
            all: Add all changes.
        """
        if all:
            self._run(["add", "-A"])
        elif paths:
            self._run(["add"] + paths)

    def commit(
        self,
        message: str,
        stage: Optional[str] = None,
        project_id: Optional[str] = None,
        planning_iter: int = 0,
        dev_iter: int = 0,
    ) -> Optional[CommitInfo]:
        """
        Create a commit with the orchestrator format.

        Args:
            message: Commit message (first line).
            stage: Current orchestrator stage.
            project_id: Current project ID.
            planning_iter: Planning iteration count.
            dev_iter: Development iteration count.

        Returns:
            CommitInfo for the new commit, or None if nothing to commit.
        """
        if self.is_clean():
            logger.info("Nothing to commit")
            return None

        # Build commit message
        full_message = self._build_commit_message(
            message=message,
            stage=stage,
            project_id=project_id,
            planning_iter=planning_iter,
            dev_iter=dev_iter,
        )

        # Stage all changes
        self.add(all=True)

        # Create commit
        self._run(["commit", "-m", full_message])

        # Get commit info
        return self.get_last_commit()

    def _build_commit_message(
        self,
        message: str,
        stage: Optional[str] = None,
        project_id: Optional[str] = None,
        planning_iter: int = 0,
        dev_iter: int = 0,
    ) -> str:
        """Build a formatted commit message."""
        lines = [message, ""]

        # Add metadata
        lines.append("Generated by: Agentic Orchestrator")
        if stage:
            lines.append(f"Stage: {stage}")
        if project_id:
            lines.append(f"Project: {project_id}")
        lines.append(f"Iteration: planning={planning_iter}, dev={dev_iter}")

        return "\n".join(lines)

    def get_last_commit(self) -> CommitInfo:
        """Get information about the last commit."""
        result = self._run(
            ["log", "-1", "--format=%H%n%h%n%s%n%an%n%ai"]
        )
        lines = result.stdout.strip().split("\n")

        return CommitInfo(
            hash=lines[0],
            short_hash=lines[1],
            message=lines[2],
            author=lines[3],
            timestamp=lines[4],
        )

    def push(
        self,
        remote: str = "origin",
        branch: Optional[str] = None,
        set_upstream: bool = False,
    ) -> bool:
        """
        Push commits to remote.

        Args:
            remote: Remote name.
            branch: Branch to push. Defaults to current branch.
            set_upstream: Set upstream tracking.

        Returns:
            True if push succeeded.
        """
        if branch is None:
            branch = self.get_current_branch()

        args = ["push"]
        if set_upstream:
            args.extend(["-u", remote, branch])
        else:
            args.extend([remote, branch])

        try:
            self._run(args)
            logger.info(f"Pushed to {remote}/{branch}")
            return True
        except GitError as e:
            logger.error(f"Push failed: {e}")
            return False

    def create_branch(self, branch_name: str, checkout: bool = True) -> None:
        """
        Create a new branch.

        Args:
            branch_name: Name of the new branch.
            checkout: Switch to the new branch.
        """
        if checkout:
            self._run(["checkout", "-b", branch_name])
        else:
            self._run(["branch", branch_name])

    def checkout(self, branch: str) -> None:
        """Checkout a branch."""
        self._run(["checkout", branch])

    def get_remote_url(self, remote: str = "origin") -> Optional[str]:
        """Get the URL of a remote."""
        try:
            result = self._run(["remote", "get-url", remote])
            return result.stdout.strip()
        except GitError:
            return None

    def configure_user(
        self,
        name: Optional[str] = None,
        email: Optional[str] = None,
    ) -> None:
        """
        Configure Git user for commits.

        Args:
            name: User name.
            email: User email.
        """
        if name:
            self._run(["config", "user.name", name])
        if email:
            self._run(["config", "user.email", email])

    def get_diff(self, staged: bool = False) -> str:
        """
        Get diff of changes.

        Args:
            staged: Get staged changes only.

        Returns:
            Diff output as string.
        """
        args = ["diff"]
        if staged:
            args.append("--staged")
        result = self._run(args)
        return result.stdout

    def get_changed_files(self, staged: bool = False) -> List[str]:
        """
        Get list of changed files.

        Args:
            staged: Get staged files only.

        Returns:
            List of changed file paths.
        """
        args = ["diff", "--name-only"]
        if staged:
            args.append("--staged")
        result = self._run(args)
        return [f for f in result.stdout.strip().split("\n") if f]

    def get_untracked_files(self) -> List[str]:
        """Get list of untracked files."""
        result = self._run(["ls-files", "--others", "--exclude-standard"])
        return [f for f in result.stdout.strip().split("\n") if f]

    def stash(self, message: Optional[str] = None) -> bool:
        """
        Stash current changes.

        Args:
            message: Optional stash message.

        Returns:
            True if changes were stashed.
        """
        args = ["stash", "push"]
        if message:
            args.extend(["-m", message])

        try:
            self._run(args)
            return True
        except GitError:
            return False

    def stash_pop(self) -> bool:
        """
        Pop the most recent stash.

        Returns:
            True if stash was applied.
        """
        try:
            self._run(["stash", "pop"])
            return True
        except GitError:
            return False

    @staticmethod
    def mask_sensitive_data(text: str) -> str:
        """
        Mask sensitive data in text (API keys, tokens).

        Args:
            text: Text that may contain sensitive data.

        Returns:
            Text with sensitive data masked.
        """
        patterns = [
            # API keys
            (r"sk-[a-zA-Z0-9]{20,}", "sk-***MASKED***"),
            (r"sk-ant-[a-zA-Z0-9-]{20,}", "sk-ant-***MASKED***"),
            # GitHub tokens
            (r"ghp_[a-zA-Z0-9]{36,}", "ghp_***MASKED***"),
            (r"gho_[a-zA-Z0-9]{36,}", "gho_***MASKED***"),
            # Google API keys
            (r"AIza[a-zA-Z0-9_-]{35}", "AIza***MASKED***"),
            # Generic patterns
            (r"(?i)(api[_-]?key|token|secret|password)\s*[=:]\s*['\"]?[a-zA-Z0-9_-]{20,}['\"]?",
             r"\1=***MASKED***"),
        ]

        masked = text
        for pattern, replacement in patterns:
            masked = re.sub(pattern, replacement, masked)

        return masked
